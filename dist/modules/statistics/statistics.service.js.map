{"version":3,"sources":["../../../src/modules/statistics/statistics.service.ts"],"sourcesContent":["import { HttpService } from '@nestjs/axios'\nimport { Injectable } from '@nestjs/common'\nimport { Observable, map, catchError, mergeMap } from 'rxjs'\n\nimport { analysisFactory } from './utils'\nimport { TimeRange } from './enums'\n\nimport { Genres, Analysis } from '@common/dtos'\nimport {\n  FormattedTrack,\n  SpotifyResponse,\n  SpotifyTrack,\n  SpotifyArtist,\n  FormattedArtist,\n  SpotifyAudioFeatures,\n} from '@common/types/spotify'\nimport { applyAuthorizationHeader, catchSpotifyError } from '~/utils'\nimport {\n  adaptArtist,\n  adaptAudioFeatures,\n  adaptGenres,\n  adaptPaginatedArtists,\n  adaptPaginatedTracks,\n  adaptTracks,\n} from '@common/adapters'\n\n@Injectable()\nexport class StatisticsService {\n  constructor(private readonly httpService: HttpService) {}\n\n  lastTracks(accessToken: string, limit = 20): Observable<FormattedTrack[]> {\n    const urlSearchParameters = new URLSearchParams({\n      limit: limit + '',\n    })\n\n    return this.httpService\n      .get<SpotifyResponse<{ track: SpotifyTrack; played_at: string }>>(\n        `/me/player/recently-played?${urlSearchParameters.toString()}`,\n        applyAuthorizationHeader(accessToken)\n      )\n      .pipe(\n        map(response => response.data),\n        map(({ items }) =>\n          items.map(({ track, played_at }) => ({\n            ...track,\n            played_at,\n          }))\n        ),\n        map(adaptTracks),\n        catchError(catchSpotifyError)\n      )\n  }\n\n  topGenres(\n    accessToken: string,\n    limit = 10,\n    timeRange = TimeRange.LONG_TERM,\n    offset = 1\n  ): Observable<Genres> {\n    const urlSearchParameters = new URLSearchParams({\n      limit: limit + '',\n      offset: offset + '',\n      time_range: timeRange,\n    })\n\n    return this.httpService\n      .get<SpotifyResponse<SpotifyArtist>>(\n        `/me/top/artists?${urlSearchParameters.toString()}`,\n        applyAuthorizationHeader(accessToken)\n      )\n      .pipe(\n        map(response => response.data.items),\n        map(items => adaptGenres(items, limit)),\n        catchError(catchSpotifyError)\n      )\n  }\n\n  topArtists(\n    accessToken: string,\n    limit = 10,\n    timeRange = TimeRange.LONG_TERM,\n    offset = 1\n  ): Observable<SpotifyResponse<FormattedArtist>> {\n    const urlSearchParameters = new URLSearchParams({\n      limit: limit + '',\n      offset: offset + '',\n      time_range: timeRange,\n    })\n\n    return this.httpService\n      .get<SpotifyResponse<SpotifyArtist>>(\n        `/me/top/artists?${urlSearchParameters.toString()}`,\n        applyAuthorizationHeader(accessToken)\n      )\n      .pipe(\n        map(response => response.data),\n        map(adaptPaginatedArtists),\n        catchError(catchSpotifyError)\n      )\n  }\n\n  topTracks(\n    accessToken: string,\n    limit = 10,\n    timeRange = TimeRange.LONG_TERM,\n    offset = 1\n  ): Observable<SpotifyResponse<FormattedTrack>> {\n    const urlSearchParameters = new URLSearchParams({\n      limit: limit + '',\n      offset: offset + '',\n      time_range: timeRange,\n    })\n\n    return this.httpService\n      .get<SpotifyResponse<SpotifyTrack>>(\n        `/me/top/tracks?${urlSearchParameters.toString()}`,\n        applyAuthorizationHeader(accessToken)\n      )\n      .pipe(\n        map(response => response.data),\n        map(adaptPaginatedTracks),\n        catchError(catchSpotifyError)\n      )\n  }\n\n  artist(accessToken: string, id: string) {\n    return this.httpService\n      .get<SpotifyArtist>(\n        `/artists/${id}`,\n        applyAuthorizationHeader(accessToken)\n      )\n      .pipe(\n        map(response => response.data),\n        map(adaptArtist),\n        catchError(catchSpotifyError)\n      )\n  }\n\n  analysis(accessToken: string): Observable<Analysis> {\n    return this.topTracks(accessToken, 50).pipe(\n      mergeMap(tracks => {\n        const tracksIds = tracks.items.map(({ id }) => id).join(',')\n\n        return this.httpService\n          .get<{ audio_features: SpotifyAudioFeatures[] }>(\n            `/audio-features?ids=${tracksIds}`,\n            applyAuthorizationHeader(accessToken)\n          )\n          .pipe(\n            map(response => response.data.audio_features),\n            map(audioFeatures =>\n              audioFeatures.map(audioFeature =>\n                adaptAudioFeatures(audioFeature)\n              )\n            ),\n            map(analysisFactory),\n            catchError(catchSpotifyError)\n          )\n      })\n    )\n  }\n}\n"],"names":["StatisticsService","lastTracks","accessToken","limit","urlSearchParameters","URLSearchParams","httpService","get","toString","applyAuthorizationHeader","pipe","map","response","data","items","track","played_at","adaptTracks","catchError","catchSpotifyError","topGenres","timeRange","TimeRange","LONG_TERM","offset","time_range","adaptGenres","topArtists","adaptPaginatedArtists","topTracks","adaptPaginatedTracks","artist","id","adaptArtist","analysis","mergeMap","tracks","tracksIds","join","audio_features","audioFeatures","audioFeature","adaptAudioFeatures","analysisFactory","constructor","Injectable"],"mappings":"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"}
